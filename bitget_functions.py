from datetime import datetime, timedelta
from typing import Dict, List, Optional, Union
from dataclasses import dataclass
from bitget.exceptions import BitgetAPIException

@dataclass
class TradeBill:
    deal_type: str
    coin_quantity: float
    coin: str
    usdt_quantity: float
    ctime: int
    fees: float

@dataclass
class TradeStatistics:
    month: int
    year: int
    start_date: str
    end_date: str
    duration: Union[int, str]
    coin: str
    coin_quantity: float
    usdt_buy_quantity: float
    usdt_sell_quantity: float
    income: float
    income_percent: float

class OrderManager:
    def __init__(self, order_api):
        self.order_api = order_api

    def _create_order_params(self, coin: str, side: str, size: float) -> Dict:
        """
        –°–æ–∑–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ä–¥–µ—Ä–∞ —Å —É—á–µ—Ç–æ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π API.
        –î–ª—è market buy - size –≤ USDT
        –î–ª—è market sell - size –≤ –±–∞–∑–æ–≤–æ–π –º–æ–Ω–µ—Ç–µ
        """
        return {
            "symbol": f"{coin}USDT",
            "side": side,
            "orderType": "market",
            "size": str(size),
            "force": "ioc"
        }

    def execute_order(self, coin: str, size: float, side: str) -> str:
        try:
            params = self._create_order_params(coin, side, size)
            print(f"Executing {side} order for {coin}")
            print(f"Order params: {params}")
            
            response = self.order_api.placeOrder(params)
            print(f"Order response: {response}")
            
            if response.get("code") == "00000":
                return response["data"]["orderId"]
            else:
                print(f"Error placing order: {response.get('msg')}")
                return ""
        except Exception as e:
            print(f"Error: {e}")
            return ""

    def buy(self, coin: str, size: float) -> str:
        """
        –°–æ–∑–¥–∞–µ—Ç –æ—Ä–¥–µ—Ä –Ω–∞ –ø–æ–∫—É–ø–∫—É
        :param coin: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'BTC')
        :param size: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ USDT –¥–ª—è –ø–æ–∫—É–ø–∫–∏
        """
        return self.execute_order(coin, size, "buy")

    def sell(self, coin: str, size: float) -> str:
        """
        –°–æ–∑–¥–∞–µ—Ç –æ—Ä–¥–µ—Ä –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
        :param coin: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'BTC')
        :param size: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç—ã –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏
        """
        return self.execute_order(coin, size, "sell")

    def get_order_info(self, order_id: str) -> Dict:
        try:
            response = self.order_api.orderInfo({"orderId": order_id})
            print(response)
            return response
        except BitgetAPIException as e:
            print(f"Error: {e.message}")
            return {}

class AssetManager:
    def __init__(self, account_api, market_api):
        self.account_api = account_api
        self.market_api = market_api

    def get_asset_quantity(self, coin: str) -> float:
        try:
            response = self.account_api.assets({"coin": coin})
            return float(response["data"][0]["available"])
        except BitgetAPIException as e:
            print(f"Error: {e.message}")
            return 0.0

    def get_ticker_price(self, coin: str) -> float:
        try:
            response = self.market_api.tickers({"symbol": f"{coin}USDT"})
            return float(response["data"][0]["lastPr"])
        except BitgetAPIException as e:
            print(f"Error: {e.message}")
            return 0.0

    def get_all_assets(self) -> List:
        try:
            return self.account_api.assets({})["data"]
        except BitgetAPIException as e:
            print(f"Error: {e.message}")
            return []

    def format_assets_message(self, assets: List) -> str:
        format_message = "–ú–æ–Ω–µ—Ç—ã –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç–µ:\n"
        usdt_message = ""

        for asset in assets:
            if asset["available"] == "0.00000000":
                continue

            if asset["coin"] != "USDT":
                price = self.get_ticker_price(asset["coin"])
                size = round(price * float(asset["available"]), 2)
                format_message += f"üíµ{float(asset['available'])} {asset['coin']} ~= {size} USDTüíµ\n"
            else:
                usdt_message += f"üí≤{round(float(asset['available']), 2)} {asset['coin']}üí≤\n"

        return format_message + usdt_message

class BillAnalyzer:
    MONTHS = {
        1: "–Ø–Ω–≤–∞—Ä—å", 2: "–§–µ–≤—Ä–∞–ª—å", 3: "–ú–∞—Ä—Ç", 4: "–ê–ø—Ä–µ–ª—å",
        5: "–ú–∞–π", 6: "–ò—é–Ω—å", 7: "–ò—é–ª—å", 8: "–ê–≤–≥—É—Å—Ç",
        9: "–°–µ–Ω—Ç—è–±—Ä—å", 10: "–û–∫—Ç—è–±—Ä—å", 11: "–ù–æ—è–±—Ä—å", 12: "–î–µ–∫–∞–±—Ä—å"
    }

    def __init__(self, account_api):
        self.account_api = account_api

    def get_account_bills(self, business_type: str, days: int) -> List:
        try:
            start_time = int((datetime.now() - timedelta(days)).timestamp() * 1000)
            params = {
                "startTime": str(start_time),
                "businessType": business_type
            }
            response = self.account_api.bills(params)
            return response["data"]
        except BitgetAPIException as e:
            print(f"error: {e.message}")
            return ""

    def process_bill(self, asset: Dict, usdt_assets: List) -> TradeBill:
        usdt_quantity = sum(
            abs(float(usdt_asset["size"]))
            for usdt_asset in usdt_assets
            if usdt_asset["coin"] == 'USDT' and usdt_asset["bizOrderId"] == asset["bizOrderId"]
        )

        deal = "–ü–æ–∫—É–ø–∫–∞" if asset["businessType"] == 'ORDER_DEALT_IN' else "–ü—Ä–æ–¥–∞–∂–∞"
        
        return TradeBill(
            deal_type=deal,
            coin_quantity=abs(float(asset["size"])),
            
            coin=asset["coin"],
            usdt_quantity=usdt_quantity,
            ctime=int(asset["cTime"]),
            fees=abs(float(asset["fees"]))
        )

    @staticmethod
    def format_trade_statistics(stat: TradeStatistics) -> str:
        status = "‚úÖ" if stat.income > 0 else "‚ùå" if stat.income < 0 else "‚û°Ô∏è"
        return (
            f"{status} {stat.coin} ({stat.coin_quantity})\n"
            f"üìÖ {stat.start_date} - {stat.end_date}\n"
            f"üí∞ –í—Ö–æ–¥: {stat.usdt_buy_quantity} USDT\n"
            f"üíµ –í—ã—Ö–æ–¥: {stat.usdt_sell_quantity} USDT\n"
            f"üìä –ü—Ä–∏–±—ã–ª—å: {stat.income} USDT ({stat.income_percent}%)\n"
            f"‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {stat.duration} –¥–Ω–µ–π\n"
            f"{'=' * 30}\n"
        )

    async def process_bills(self, days: int) -> tuple[List[TradeStatistics], Dict]:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–¥–µ–ª–∫–∏
        buy_bills = self.get_account_bills('ORDER_DEALT_IN', days)
        sell_bills = self.get_account_bills('ORDER_DEALT_OUT', days)
        usdt_bills = self.get_account_bills('USDT', days)

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–¥–µ–ª–∫–∏
        processed_buy_bills = [
            self.bill_analyzer.process_bill(bill, usdt_bills)
            for bill in buy_bills
        ]
        processed_sell_bills = [
            self.bill_analyzer.process_bill(bill, usdt_bills)
            for bill in sell_bills
        ]

        # –°–æ–∑–¥–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–∞—Ä–∞–º —Å–¥–µ–ª–æ–∫
        stats = []
        coins_in_trade = {}
        
        for buy_bill in processed_buy_bills:
            # –ò—â–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é —Å–¥–µ–ª–∫—É –ø—Ä–æ–¥–∞–∂–∏
            matching_sell = next(
                (sell for sell in processed_sell_bills 
                if sell.coin == buy_bill.coin 
                and sell.ctime > buy_bill.ctime),
                None
            )
            
            stat = self.create_statistics(buy_bill, matching_sell)
            
            if matching_sell:
                stats.append(stat)
            else:
                coins_in_trade[buy_bill.coin] = stat

        return stats, coins_in_trade

    def create_statistics(self, bill: TradeBill, sell_bill: Optional[TradeBill] = None) -> TradeStatistics:
        buy_date = datetime.fromtimestamp(bill.ctime/1000.0)
        sell_date = datetime.fromtimestamp(sell_bill.ctime/1000.0) if sell_bill else None

        usdt_buy_quantity = round(float(bill.usdt_quantity) + float(bill.fees), 2)
        usdt_sell_quantity = round(float(sell_bill.usdt_quantity) if sell_bill else 0, 2)

        return TradeStatistics(
            month=int(sell_date.strftime("%m")) if sell_bill else 0,
            year=int(sell_date.strftime("%Y")) if sell_bill else 0,
            start_date=buy_date.strftime("%d.%m.%Y %H:%M"),
            end_date=sell_date.strftime("%d.%m.%Y %H:%M") if sell_bill else "",
            duration=(sell_date - buy_date).days if sell_bill else "—Å–¥–µ–ª–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ",
            coin=bill.coin,
            coin_quantity=float(bill.coin_quantity),
            usdt_buy_quantity=usdt_buy_quantity,
            usdt_sell_quantity=usdt_sell_quantity,
            income=round(usdt_sell_quantity - usdt_buy_quantity, 2) if sell_bill else 0,
            income_percent=round((usdt_sell_quantity - usdt_buy_quantity) / usdt_buy_quantity * 100, 2) if sell_bill else 0
        )

    def format_monthly_statistics(self, stats: List[TradeStatistics]) -> str:
        if not stats:
            return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"

        current_month = {"month": 0, "year": 0}
        metrics = {
            "income": 0, "all_percent": 0, "profit_count": 0,
            "loss_count": 0, "max_loss_percent": 0
        }
        
        result = "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –º–µ—Å—è—Ü–∞–º:\n"

        for stat in stats:
            if current_month["month"] != stat.month:
                if current_month["month"] != 0:
                    result += self._format_month_summary(current_month, metrics)
                    metrics = {
                        "income": 0, "all_percent": 0, "profit_count": 0,
                        "loss_count": 0, "max_loss_percent": 0
                    }
                current_month = {"month": stat.month, "year": stat.year}

            self._update_metrics(metrics, stat)

        if current_month["month"] != 0:
            result += self._format_month_summary(current_month, metrics)

        return result

    def _format_month_summary(self, current_month: Dict, metrics: Dict) -> str:
        total_deals = metrics["profit_count"] + metrics["loss_count"]
        avg_percent = round(metrics["all_percent"] / total_deals, 2) if total_deals > 0 else 0
        profit_percent = round((metrics["profit_count"] * 100) / total_deals, 2) if total_deals > 0 else 0

        return (
            f"‚ÑπÔ∏è–î–∞–Ω–Ω—ã–µ –∑–∞ {self.MONTHS.get(current_month['month'], '')} {current_month['year']} –≥.:‚ÑπÔ∏è\n"
            f"üí∂–ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å - {round(metrics['income'], 2)} UDSTüí∂\n"
            f"üíµ–ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å% - {round(metrics['all_percent'], 2)}%üíµ\n"
            f"ü§ù–ó–∞–∫—Ä—ã—Ç—ã—Ö —Å–¥–µ–ª–æ–∫ - {total_deals}ü§ù\n"
            f"üìà–ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö - {profit_percent}%üìà\n"
            f"üìâ–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞ - {metrics['max_loss_percent']}%üìâ\n"
            f"üí∞–°—Ä–µ–¥–Ω–∏–π –¥–æ—Ö–æ–¥ –ø–æ —Å–¥–µ–ª–∫–µ - {avg_percent}%üí∞\n\n"
        )

    def _update_metrics(self, metrics: Dict, stat: TradeStatistics) -> None:
        metrics["income"] += stat.income
        metrics["all_percent"] += stat.income_percent
        
        if stat.income_percent > 0:
            metrics["profit_count"] += 1
        elif stat.income_percent < 0:
            metrics["loss_count"] += 1
            metrics["max_loss_percent"] = min(metrics["max_loss_percent"], stat.income_percent)